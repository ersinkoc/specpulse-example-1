/**
 * Vulnerability Scanner Engine
 * Comprehensive vulnerability scanning with OWASP Dependency-Check integration
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const winston = require('winston');
const Vulnerability = require('../../../models/security/Vulnerability');
const { secureDatabase } = require('../../../config/database-security');

class VulnerabilityScanner {
  constructor(config = {}) {
    this.config = {
      enabled: config.enabled !== false,
      scanInterval: config.scanInterval || '0 2 * * *', // Daily at 2 AM
      timeout: config.timeout || 300000, // 5 minutes
      cacheEnabled: config.cacheEnabled !== false,
      cacheExpiry: config.cacheExpiry || 86400000, // 24 hours
      scanPath: config.scanPath || process.cwd(),
      reportPath: config.reportPath || path.join(process.cwd(), 'reports', 'vulnerability'),
      maxRetries: config.maxRetries || 3,
      retryDelay: config.retryDelay || 5000,
      snykToken: config.snykToken || process.env.SNYK_TOKEN,
      notificationThresholds: config.notificationThresholds || {
        high: 7,
        critical: 9
      },
      externalScanners: {
        owaspDependencyCheck: config.owaspDependencyCheck !== false,
        snyk: config.snyk && this.config.snykToken,
        npmAudit: config.npmAudit !== false
      },
      ...config
    };

    this.cache = new Map();
    this.isScanning = false;
    this.lastScanTime = null;
    this.scanResults = [];

    // Initialize logger
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      ),
      transports: [
        new winston.transports.Console({ format: winston.format.simple() }),
        new winston.transports.File({
          filename: path.join(process.cwd(), 'logs', 'vulnerability-scanner.log')
        })
      ]
    });

    this.initialize();
  }

  /**
   * Initialize vulnerability scanner
   */
  async initialize() {
    try {
      // Ensure report directory exists
      await fs.promises.mkdir(this.config.reportPath, { recursive: true });

      // Initialize database connection
      if (this.config.enabled) {
        await secureDatabase.initialize();
      }

      this.logger.info('Vulnerability scanner initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize vulnerability scanner:', error);
      throw error;
    }
  }

  /**
   * Perform comprehensive vulnerability scan
   */
  async scan() {
    if (!this.config.enabled) {
      this.logger.info('Vulnerability scanning is disabled');
      return [];
    }

    if (this.isScanning) {
      this.logger.warn('Scan already in progress, skipping');
      return this.scanResults;
    }

    this.isScanning = true;
    const scanId = crypto.randomUUID();

    try {
      this.logger.info(`Starting vulnerability scan ${scanId}`);

      const scanResults = {
        scanId,
        startTime: new Date(),
        vulnerabilities: [],
        scannerResults: {}
      };

      // Check cache first
      const cacheKey = this.generateCacheKey();
      if (this.config.cacheEnabled && this.cache.has(cacheKey)) {
        const cached = this.cache.get(cacheKey);
        if (Date.now() - cached.timestamp < this.config.cacheExpiry) {
          this.logger.info('Returning cached scan results');
          this.scanResults = cached.vulnerabilities;
          return cached.vulnerabilities;
        }
      }

      // Run different scanners
      const scannerPromises = [];

      if (this.config.externalScanners.owaspDependencyCheck) {
        scannerPromises.push(this.runOWASPDependencyCheck(scanResults));
      }

      if (this.config.externalScanners.snyk) {
        scannerPromises.push(this.runSnykScan(scanResults));
      }

      if (this.config.externalScanners.npmAudit) {
        scannerPromises.push(this.runNpmAudit(scanResults));
      }

      // Wait for all scanners to complete
      const results = await Promise.allSettled(scannerPromises);

      // Process results
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          scanResults.vulnerabilities.push(...result.value);
        } else {
          this.logger.error(`Scanner ${index} failed:`, result.reason);
        }
      });

      // Deduplicate and normalize vulnerabilities
      scanResults.vulnerabilities = this.deduplicateVulnerabilities(scanResults.vulnerabilities);

      // Save scan results
      await this.saveScanResults(scanResults);

      // Cache results
      if (this.config.cacheEnabled) {
        this.cache.set(cacheKey, {
          timestamp: Date.now(),
          vulnerabilities: scanResults.vulnerabilities
        });
      }

      // Update last scan time
      this.lastScanTime = new Date();
      this.scanResults = scanResults.vulnerabilities;

      scanResults.endTime = new Date();
      scanResults.duration = scanResults.endTime - scanResults.startTime;

      this.logger.info(`Vulnerability scan ${scanId} completed in ${scanResults.duration}ms`, {
        vulnerabilitiesFound: scanResults.vulnerabilities.length,
        critical: scanResults.vulnerabilities.filter(v => v.severity === 'critical').length,
        high: scanResults.vulnerabilities.filter(v => v.severity === 'high').length
      });

      return scanResults.vulnerabilities;

    } catch (error) {
      this.logger.error('Vulnerability scan failed:', error);
      throw error;
    } finally {
      this.isScanning = false;
    }
  }

  /**
   * Run OWASP Dependency-Check
   */
  async runOWASPDependencyCheck(scanResults) {
    try {
      this.logger.info('Running OWASP Dependency-Check...');

      const reportPath = path.join(this.config.reportPath, `owasp-${Date.now()}.json`);

      const command = `dependency-check --project "Security Audit System" --scan "${this.config.scanPath}" --format JSON --out "${this.config.reportPath}" --suppression "${path.join(__dirname, '../../../config/suppressions.xml')}"`;

      this.logger.info(`Executing: ${command}`);

      const output = execSync(command, {
        encoding: 'utf8',
        timeout: this.config.timeout,
        cwd: this.config.scanPath
      });

      // Parse OWASP report
      const reportFile = path.join(this.config.reportPath, 'dependency-check-report.json');
      const reportData = JSON.parse(fs.readFileSync(reportFile, 'utf8'));

      const vulnerabilities = this.parseOWASPReport(reportData);

      scanResults.scannerResults.owasp = {
        success: true,
        vulnerabilitiesFound: vulnerabilities.length,
        reportPath
      };

      this.logger.info(`OWASP Dependency-Check completed: ${vulnerabilities.length} vulnerabilities found`);
      return vulnerabilities;

    } catch (error) {
      this.logger.error('OWASP Dependency-Check failed:', error);
      scanResults.scannerResults.owasp = {
        success: false,
        error: error.message
      };
      return [];
    }
  }

  /**
   * Run Snyk vulnerability scan
   */
  async runSnykScan(scanResults) {
    try {
      this.logger.info('Running Snyk scan...');

      const command = `snyk test --json --severity-threshold=high`;

      const output = execSync(command, {
        encoding: 'utf8',
        timeout: this.config.timeout,
        cwd: this.config.scanPath,
        env: {
          ...process.env,
          SNYK_TOKEN: this.config.snykToken
        }
      });

      const snykData = JSON.parse(output);
      const vulnerabilities = this.parseSnykReport(snykData);

      scanResults.scannerResults.snyk = {
        success: true,
        vulnerabilitiesFound: vulnerabilities.length
      };

      this.logger.info(`Snyk scan completed: ${vulnerabilities.length} vulnerabilities found`);
      return vulnerabilities;

    } catch (error) {
      this.logger.error('Snyk scan failed:', error);
      scanResults.scannerResults.snyk = {
        success: false,
        error: error.message
      };
      return [];
    }
  }

  /**
   * Run npm audit
   */
  async runNpmAudit(scanResults) {
    try {
      this.logger.info('Running npm audit...');

      const command = `npm audit --json --audit-level=moderate`;

      const output = execSync(command, {
        encoding: 'utf8',
        timeout: this.config.timeout,
        cwd: this.config.scanPath
      });

      const auditData = JSON.parse(output);
      const vulnerabilities = this.parseNpmAuditReport(auditData);

      scanResults.scannerResults.npmAudit = {
        success: true,
        vulnerabilitiesFound: vulnerabilities.length
      };

      this.logger.info(`npm audit completed: ${vulnerabilities.length} vulnerabilities found`);
      return vulnerabilities;

    } catch (error) {
      // npm audit exits with non-zero code when vulnerabilities are found
      if (error.stdout) {
        try {
          const auditData = JSON.parse(error.stdout);
          const vulnerabilities = this.parseNpmAuditReport(auditData);

          scanResults.scannerResults.npmAudit = {
            success: true,
            vulnerabilitiesFound: vulnerabilities.length
          };

          this.logger.info(`npm audit completed: ${vulnerabilities.length} vulnerabilities found`);
          return vulnerabilities;
        } catch (parseError) {
          this.logger.error('Failed to parse npm audit output:', parseError);
        }
      }

      this.logger.error('npm audit failed:', error);
      scanResults.scannerResults.npmAudit = {
        success: false,
        error: error.message
      };
      return [];
    }
  }

  /**
   * Parse OWASP Dependency-Check report
   */
  parseOWASPReport(reportData) {
    const vulnerabilities = [];

    if (reportData.dependencies) {
      reportData.dependencies.forEach(dep => {
        if (dep.vulnerabilities) {
          dep.vulnerabilities.forEach(vuln => {
            vulnerabilities.push(Vulnerability.fromScannerData({
              name: vuln.name || vuln.cve,
              description: vuln.description,
              severity: this.mapOWASPSeverity(vuln.severity),
              cvssScore: vuln.cvssScore,
              cve: vuln.cve,
              affectedComponent: dep.fileName,
              versionAffected: dep.identifiers?.version,
              scanner: 'owasp-dependency-check',
              references: vuln.references || [],
              discoveredAt: new Date()
            }));
          });
        }
      });
    }

    return vulnerabilities;
  }

  /**
   * Parse Snyk report
   */
  parseSnykReport(snykData) {
    const vulnerabilities = [];

    if (snykData.vulnerabilities) {
      snykData.vulnerabilities.forEach(vuln => {
        vulnerabilities.push(Vulnerability.fromScannerData({
          name: vuln.title,
          description: vuln.description,
          severity: this.mapSnykSeverity(vuln.severity),
          cvssScore: vuln.cvssScore,
          cve: vuln.identifiers?.CVE?.[0],
          affectedComponent: vuln.packageName,
          versionAffected: vuln.from?.[1],
          versionFixed: vuln.fixedIn?.[0],
          scanner: 'snyk',
          references: vuln.references || [],
          discoveredAt: new Date()
        }));
      });
    }

    return vulnerabilities;
  }

  /**
   * Parse npm audit report
   */
  parseNpmAuditReport(auditData) {
    const vulnerabilities = [];

    if (auditData.vulnerabilities) {
      Object.values(auditData.vulnerabilities).forEach(advisory => {
        vulnerabilities.push(Vulnerability.fromScannerData({
          name: advisory.title,
          description: advisory.overview,
          severity: this.mapNpmAuditSeverity(advisory.severity),
          cve: advisory.cwe,
          affectedComponent: advisory.module_name,
          versionAffected: advisory.findings?.[0]?.version,
          versionFixed: advisory.findings?.[0]?.paths?.[0],
          scanner: 'npm-audit',
          references: advisory.references || [],
          discoveredAt: new Date()
        }));
      });
    }

    return vulnerabilities;
  }

  /**
   * Map OWASP severity levels
   */
  mapOWASPSeverity(severity) {
    const mapping = {
      'CRITICAL': 'critical',
      'HIGH': 'high',
      'MEDIUM': 'medium',
      'LOW': 'low',
      'INFO': 'info'
    };
    return mapping[severity] || 'medium';
  }

  /**
   * Map Snyk severity levels
   */
  mapSnykSeverity(severity) {
    const mapping = {
      'critical': 'critical',
      'high': 'high',
      'medium': 'medium',
      'low': 'low'
    };
    return mapping[severity] || 'medium';
  }

  /**
   * Map npm audit severity levels
   */
  mapNpmAuditSeverity(severity) {
    const mapping = {
      'critical': 'critical',
      'high': 'high',
      'moderate': 'medium',
      'low': 'low',
      'info': 'info'
    };
    return mapping[severity] || 'medium';
  }

  /**
   * Deduplicate vulnerabilities from multiple scanners
   */
  deduplicateVulnerabilities(vulnerabilities) {
    const seen = new Set();
    const deduplicated = [];

    vulnerabilities.forEach(vuln => {
      const key = `${vuln.name}-${vuln.affectedComponent}-${vuln.versionAffected}`;

      if (!seen.has(key)) {
        seen.add(key);
        deduplicated.push(vuln);
      } else {
        // Merge information from different scanners
        const existing = deduplicated.find(v => v.name === vuln.name && v.affectedComponent === vuln.affectedComponent);
        if (existing) {
          // Merge references and take highest severity
          existing.references = [...new Set([...existing.references, ...vuln.references])];
          if (vuln.cvssScore && (!existing.cvssScore || vuln.cvssScore > existing.cvssScore)) {
            existing.severity = vuln.severity;
            existing.cvssScore = vuln.cvssScore;
          }
        }
      }
    });

    return deduplicated;
  }

  /**
   * Save scan results to database
   */
  async saveScanResults(scanResults) {
    try {
      const client = await secureDatabase.pool.connect();

      try {
        await client.query('BEGIN');

        // Insert or update vulnerabilities
        for (const vuln of scanResults.vulnerabilities) {
          const dbRow = vuln.toDbRow();

          await client.query(`
            INSERT INTO vulnerabilities (
              id, name, description, severity, cvss_score, cve, affected_component,
              version_affected, version_fixed, scanner, discovered_at, status,
              remediation_steps, references, metadata, created_at, updated_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
            ON CONFLICT (name, affected_component, version_affected)
            DO UPDATE SET
              severity = EXCLUDED.severity,
              cvss_score = EXCLUDED.cvss_score,
              version_fixed = EXCLUDED.version_fixed,
              scanner = EXCLUDED.scanner,
              discovered_at = EXCLUDED.discovered_at,
              updated_at = NOW()
          `, [
            dbRow.id, dbRow.name, dbRow.description, dbRow.severity, dbRow.cvss_score,
            dbRow.cve, dbRow.affected_component, dbRow.version_affected, dbRow.version_fixed,
            dbRow.scanner, dbRow.discovered_at, dbRow.status, dbRow.remediation_steps,
            dbRow.references, dbRow.metadata, dbRow.created_at, dbRow.updated_at
          ]);
        }

        await client.query('COMMIT');
        this.logger.info(`Saved ${scanResults.vulnerabilities.length} vulnerabilities to database`);

      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }

    } catch (error) {
      this.logger.error('Failed to save scan results to database:', error);
    }
  }

  /**
   * Get scan statistics
   */
  getStatistics() {
    const stats = {
      isScanning: this.isScanning,
      lastScanTime: this.lastScanTime,
      cachedResults: this.cache.size,
      totalVulnerabilities: this.scanResults.length,
      criticalCount: this.scanResults.filter(v => v.severity === 'critical').length,
      highCount: this.scanResults.filter(v => v.severity === 'high').length,
      mediumCount: this.scanResults.filter(v => v.severity === 'medium').length,
      lowCount: this.scanResults.filter(v => v.severity === 'low').length,
      infoCount: this.scanResults.filter(v => v.severity === 'info').length
    };

    return stats;
  }

  /**
   * Generate cache key
   */
  generateCacheKey() {
    const packageJsonPath = path.join(this.config.scanPath, 'package.json');
    let hash = '';

    try {
      const packageJson = fs.readFileSync(packageJsonPath, 'utf8');
      hash = crypto.createHash('md5').update(packageJson).digest('hex');
    } catch (error) {
      this.logger.warn('Could not read package.json for cache key:', error.message);
    }

    return `vuln-scan-${hash}`;
  }

  /**
   * Clear cache
   */
  clearCache() {
    this.cache.clear();
    this.logger.info('Vulnerability scanner cache cleared');
  }

  /**
   * Schedule regular scans
   */
  scheduleScanning(cronInstance) {
    if (!this.config.enabled) {
      return;
    }

    cronInstance.schedule(this.config.scanInterval, async () => {
      try {
        await this.scan();
      } catch (error) {
        this.logger.error('Scheduled vulnerability scan failed:', error);
      }
    });

    this.logger.info(`Vulnerability scanning scheduled with pattern: ${this.config.scanInterval}`);
  }
}

module.exports = VulnerabilityScanner;