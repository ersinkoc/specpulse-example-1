/**
 * Vulnerability Model
 * Security vulnerability management and tracking
 */

const { v4: uuidv4 } = require('uuid');

class Vulnerability {
  constructor(data = {}) {
    this.id = data.id || uuidv4();
    this.name = data.name;
    this.description = data.description;
    this.severity = data.severity || 'medium';
    this.cvssScore = data.cvssScore || null;
    this.cve = data.cve || null;
    this.affectedComponent = data.affectedComponent;
    this.versionAffected = data.versionAffected;
    this.versionFixed = data.versionFixed || null;
    this.scanner = data.scanner || 'unknown';
    this.discoveredAt = data.discoveredAt || new Date();
    this.status = data.status || 'open';
    this.resolvedAt = data.resolvedAt || null;
    this.resolvedBy = data.resolvedBy || null;
    this.remediationSteps = data.remediationSteps || null;
    this.references = data.references || [];
    this.metadata = data.metadata || {};
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Create vulnerability from scanner data
   */
  static fromScannerData(scannerData) {
    return new Vulnerability({
      name: scannerData.name || scannerData.cve || 'Unknown Vulnerability',
      description: scannerData.description,
      severity: this.mapCVSSSeverity(scannerData.cvssScore),
      cvssScore: scannerData.cvssScore,
      cve: scannerData.cve,
      affectedComponent: scannerData.dependency || scannerData.component,
      versionAffected: scannerData.version,
      versionFixed: scannerData.fixedVersion,
      scanner: scannerData.scanner || 'unknown',
      discoveredAt: new Date(),
      references: scannerData.references || []
    });
  }

  /**
   * Map CVSS score to severity level
   */
  static mapCVSSSeverity(cvssScore) {
    if (!cvssScore) return 'medium';

    if (cvssScore >= 9.0) return 'critical';
    if (cvssScore >= 7.0) return 'high';
    if (cvssScore >= 4.0) return 'medium';
    if (cvssScore > 0.0) return 'low';
    return 'info';
  }

  /**
   * Convert to database format
   */
  toDbRow() {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      severity: this.severity,
      cvss_score: this.cvssScore,
      cve: this.cve,
      affected_component: this.affectedComponent,
      version_affected: this.versionAffected,
      version_fixed: this.versionFixed,
      scanner: this.scanner,
      discovered_at: this.discoveredAt,
      status: this.status,
      resolved_at: this.resolvedAt,
      resolved_by: this.resolvedBy,
      remediation_steps: this.remediationSteps,
      references: JSON.stringify(this.references),
      metadata: JSON.stringify(this.metadata),
      created_at: this.createdAt,
      updated_at: this.updatedAt
    };
  }

  /**
   * Create from database row
   */
  static fromDbRow(row) {
    return new Vulnerability({
      id: row.id,
      name: row.name,
      description: row.description,
      severity: row.severity,
      cvssScore: row.cvss_score,
      cve: row.cve,
      affectedComponent: row.affected_component,
      versionAffected: row.version_affected,
      versionFixed: row.version_fixed,
      scanner: row.scanner,
      discoveredAt: row.discovered_at,
      status: row.status,
      resolvedAt: row.resolved_at,
      resolvedBy: row.resolved_by,
      remediationSteps: row.remediation_steps,
      references: row.references ? JSON.parse(row.references) : [],
      metadata: row.metadata ? JSON.parse(row.metadata) : {},
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }

  /**
   * Validate vulnerability data
   */
  validate() {
    const errors = [];

    if (!this.name) {
      errors.push('Vulnerability name is required');
    }

    const validSeverities = ['info', 'low', 'medium', 'high', 'critical'];
    if (!validSeverities.includes(this.severity)) {
      errors.push('Severity must be one of: info, low, medium, high, critical');
    }

    if (this.cvssScore && (this.cvssScore < 0 || this.cvssScore > 10)) {
      errors.push('CVSS score must be between 0 and 10');
    }

    const validStatuses = ['open', 'in_progress', 'resolved', 'false_positive', 'wont_fix'];
    if (!validStatuses.includes(this.status)) {
      errors.push('Status must be one of: open, in_progress, resolved, false_positive, wont_fix');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Mark vulnerability as resolved
   */
  markResolved(resolvedBy, resolutionNotes) {
    this.status = 'resolved';
    this.resolvedAt = new Date();
    this.resolvedBy = resolvedBy;
    this.updatedAt = new Date();

    if (resolutionNotes) {
      this.remediationSteps = resolutionNotes;
    }
  }

  /**
   * Mark vulnerability as false positive
   */
  markFalsePositive(reason) {
    this.status = 'false_positive';
    this.updatedAt = new Date();

    if (reason) {
      this.metadata.falsePositiveReason = reason;
    }
  }

  /**
   * Mark vulnerability as won't fix
   */
  markWontFix(reason, riskAcceptance) {
    this.status = 'wont_fix';
    this.updatedAt = new Date();

    if (reason) {
      this.metadata.wontFixReason = reason;
    }

    if (riskAcceptance) {
      this.metadata.riskAcceptance = riskAcceptance;
    }
  }

  /**
   * Get severity priority for sorting
   */
  getSeverityPriority() {
    const priorities = {
      info: 0,
      low: 1,
      medium: 2,
      high: 3,
      critical: 4
    };
    return priorities[this.severity] || 2;
  }

  /**
   * Check if vulnerability is critical
   */
  isCritical() {
    return this.severity === 'critical';
  }

  /**
   * Check if vulnerability is high severity
   */
  isHighSeverity() {
    return ['high', 'critical'].includes(this.severity);
  }

  /**
   * Check if vulnerability is resolved
   */
  isResolved() {
    return this.status === 'resolved';
  }

  /**
   * Check if vulnerability is open
   */
  isOpen() {
    return ['open', 'in_progress'].includes(this.status);
  }

  /**
   * Calculate age in days
   */
  getAgeInDays() {
    const now = new Date();
    const discovered = new Date(this.discoveredAt);
    return Math.floor((now - discovered) / (1000 * 60 * 60 * 24));
  }

  /**
   * Check if vulnerability is old (older than 30 days)
   */
  isOld() {
    return this.getAgeInDays() > 30;
  }

  /**
   * Check if vulnerability is very old (older than 90 days)
   */
  isVeryOld() {
    return this.getAgeInDays() > 90;
  }

  /**
   * Generate remediation suggestions
   */
  generateRemediationSuggestions() {
    const suggestions = [];

    if (this.versionFixed) {
      suggestions.push(`Upgrade to version ${this.versionFixed} or later`);
    }

    if (this.severity === 'critical' || this.severity === 'high') {
      suggestions.push('Prioritize immediate remediation due to high severity');
    }

    if (this.isVeryOld()) {
      suggestions.push('Address immediately - vulnerability is very old');
    }

    if (this.affectedComponent) {
      suggestions.push(`Review all instances of ${this.affectedComponent}`);
    }

    if (this.cve) {
      suggestions.push(`Review CVE details: ${this.cve}`);
    }

    return suggestions;
  }

  /**
   * Get risk score considering severity and age
   */
  getRiskScore() {
    let baseScore = this.getSeverityPriority();

    // Increase score based on age
    const ageInDays = this.getAgeInDays();
    if (ageInDays > 90) baseScore += 2;
    else if (ageInDays > 30) baseScore += 1;

    // Increase score if no fix available
    if (!this.versionFixed && this.status === 'open') {
      baseScore += 1;
    }

    return Math.min(baseScore, 5); // Cap at 5
  }

  /**
   * Convert to JSON representation
   */
  toJSON() {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      severity: this.severity,
      cvssScore: this.cvssScore,
      cve: this.cve,
      affectedComponent: this.affectedComponent,
      versionAffected: this.versionAffected,
      versionFixed: this.versionFixed,
      scanner: this.scanner,
      discoveredAt: this.discoveredAt.toISOString(),
      status: this.status,
      resolvedAt: this.resolvedAt ? this.resolvedAt.toISOString() : null,
      resolvedBy: this.resolvedBy,
      remediationSteps: this.remediationSteps,
      references: this.references,
      metadata: this.metadata,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString(),
      ageInDays: this.getAgeInDays(),
      riskScore: this.getRiskScore(),
      remediationSuggestions: this.generateRemediationSuggestions()
    };
  }

  /**
   * Create summary representation
   */
  toSummary() {
    return {
      id: this.id,
      name: this.name,
      severity: this.severity,
      cvssScore: this.cvssScore,
      cve: this.cve,
      affectedComponent: this.affectedComponent,
      status: this.status,
      discoveredAt: this.discoveredAt.toISOString(),
      ageInDays: this.getAgeInDays(),
      riskScore: this.getRiskScore()
    };
  }
}

module.exports = Vulnerability;