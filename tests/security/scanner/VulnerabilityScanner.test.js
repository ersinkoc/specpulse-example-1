/**
 * Security Tests: Vulnerability Scanner
 * Tests for vulnerability scanning functionality
 */

const VulnerabilityScanner = require('../../../src/security/scanner/VulnerabilityScanner');
const fs = require('fs');
const path = require('path');

// Mock external dependencies
jest.mock('child_process');
jest.mock('fs');

describe('VulnerabilityScanner', () => {
  let scanner;

  beforeEach(() => {
    scanner = new VulnerabilityScanner();
    jest.clearAllMocks();
  });

  describe('constructor', () => {
    test('should initialize with default configuration', () => {
      expect(scanner.config).toBeDefined();
      expect(scanner.config.scanning.enabled).toBe(true);
      expect(scanner.config.notifications.enabled).toBe(true);
    });

    test('should accept custom configuration', () => {
      const customConfig = {
        scanning: {
          enabled: false,
          timeout: 600000
        }
      };

      const customScanner = new VulnerabilityScanner(customConfig);
      expect(customScanner.config.scanning.enabled).toBe(false);
      expect(customScanner.config.scanning.timeout).toBe(600000);
    });
  });

  describe('scanDependencies', () => {
    test('should scan dependencies and return results', async () => {
      const mockScanResult = {
        dependencies: [
          {
            fileName: 'express-4.18.2.tgz',
            vulnerabilities: [
              {
                name: 'CVE-2023-1234',
                severity: 'HIGH',
                cvssScore: 8.5,
                description: 'Test vulnerability'
              }
            ]
          }
        ]
      };

      // Mock dependency check execution
      const { execSync } = require('child_process');
      execSync.mockReturnValue(JSON.stringify(mockScanResult));

      // Mock file system
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(JSON.stringify(mockScanResult));

      const results = await scanner.scanDependencies();

      expect(results).toHaveLength(1);
      expect(results[0].severity).toBe('HIGH');
      expect(results[0].cvssScore).toBe(8.5);
    });

    test('should handle scan failures gracefully', async () => {
      const { execSync } = require('child_process');
      execSync.mockImplementation(() => {
        throw new Error('Scan failed');
      });

      await expect(scanner.scanDependencies()).rejects.toThrow('Scan failed');
    });

    test('should cache results when enabled', async () => {
      const mockScanResult = { dependencies: [] };

      // Mock file system for caching
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue(JSON.stringify(mockScanResult));

      const results = await scanner.scanDependencies();
      expect(fs.existsSync).toHaveBeenCalled();
      expect(fs.readFileSync).toHaveBeenCalled();
    });
  });

  describe('analyzeSeverity', () => {
    test('should correctly classify vulnerability severity', () => {
      expect(scanner.analyzeSeverity(9.5)).toBe('CRITICAL');
      expect(scanner.analyzeSeverity(8.0)).toBe('HIGH');
      expect(scanner.analyzeSeverity(6.5)).toBe('MEDIUM');
      expect(scanner.analyzeSeverity(3.0)).toBe('LOW');
      expect(scanner.analyzeSeverity(0.0)).toBe('INFO');
    });

    test('should handle edge cases', () => {
      expect(scanner.analyzeSeverity(10.0)).toBe('CRITICAL');
      expect(scanner.analyzeSeverity(7.0)).toBe('HIGH');
      expect(scanner.analyzeSeverity(4.0)).toBe('MEDIUM');
      expect(scanner.analyzeSeverity(1.0)).toBe('LOW');
    });
  });

  describe('filterByThreshold', () => {
    test('should filter vulnerabilities by severity threshold', () => {
      const vulnerabilities = [
        { severity: 'CRITICAL', cvssScore: 9.5 },
        { severity: 'HIGH', cvssScore: 8.0 },
        { severity: 'MEDIUM', cvssScore: 6.5 },
        { severity: 'LOW', cvssScore: 3.0 }
      ];

      const highThreshold = scanner.filterByThreshold(vulnerabilities, 'HIGH');
      expect(highThreshold).toHaveLength(2);
      expect(highThreshold.every(v => v.severity === 'CRITICAL' || v.severity === 'HIGH')).toBe(true);

      const criticalThreshold = scanner.filterByThreshold(vulnerabilities, 'CRITICAL');
      expect(criticalThreshold).toHaveLength(1);
      expect(criticalThreshold[0].severity).toBe('CRITICAL');
    });
  });

  describe('generateReport', () => {
    test('should generate comprehensive vulnerability report', () => {
      const vulnerabilities = [
        {
          severity: 'HIGH',
          dependency: 'express',
          name: 'CVE-2023-1234',
          cvssScore: 8.5,
          description: 'Test vulnerability'
        }
      ];

      const report = scanner.generateReport(vulnerabilities);

      expect(report).toHaveProperty('timestamp');
      expect(report).toHaveProperty('summary');
      expect(report).toHaveProperty('vulnerabilities');
      expect(report.summary.total).toBe(1);
      expect(report.summary.high).toBe(1);
      expect(report.vulnerabilities).toHaveLength(1);
    });

    test('should categorize vulnerabilities correctly', () => {
      const vulnerabilities = [
        { severity: 'CRITICAL' },
        { severity: 'HIGH' },
        { severity: 'HIGH' },
        { severity: 'MEDIUM' },
        { severity: 'LOW' }
      ];

      const report = scanner.generateReport(vulnerabilities);

      expect(report.summary.critical).toBe(1);
      expect(report.summary.high).toBe(2);
      expect(report.summary.medium).toBe(1);
      expect(report.summary.low).toBe(1);
      expect(report.summary.total).toBe(5);
    });
  });

  describe('notifyAdministrators', () => {
    test('should send notifications for critical vulnerabilities', async () => {
      const vulnerabilities = [
        { severity: 'CRITICAL', name: 'CVE-2023-1234' }
      ];

      // Mock notification service
      const mockNotify = jest.fn();
      scanner.notificationService = { send: mockNotify };

      await scanner.notifyAdministrators(vulnerabilities);

      expect(mockNotify).toHaveBeenCalledWith({
        type: 'security_alert',
        severity: 'CRITICAL',
        message: expect.stringContaining('CVE-2023-1234'),
        vulnerabilities
      });
    });

    test('should not send notifications for low severity', async () => {
      const vulnerabilities = [
        { severity: 'LOW', name: 'CVE-2023-5678' }
      ];

      const mockNotify = jest.fn();
      scanner.notificationService = { send: mockNotify };

      await scanner.notifyAdministrators(vulnerabilities);

      expect(mockNotify).not.toHaveBeenCalled();
    });
  });

  describe('scheduledScanning', () => {
    test('should schedule scans according to configuration', () => {
      const mockSchedule = jest.fn();
      scanner.cronService = { schedule: mockSchedule };

      scanner.setupScheduledScanning();

      expect(mockSchedule).toHaveBeenCalledWith(
        expect.any(String),
        expect.any(Function)
      );
    });

    test('should not schedule when disabled', () => {
      scanner.config.scanning.enabled = false;
      const mockSchedule = jest.fn();
      scanner.cronService = { schedule: mockSchedule };

      scanner.setupScheduledScanning();

      expect(mockSchedule).not.toHaveBeenCalled();
    });
  });

  describe('error handling', () => {
    test('should handle network timeouts during scanning', async () => {
      const { execSync } = require('child_process');
      execSync.mockImplementation(() => {
        const error = new Error('ETIMEDOUT');
        error.code = 'ETIMEDOUT';
        throw error;
      });

      await expect(scanner.scanDependencies()).rejects.toThrow('ETIMEDOUT');
    });

    test('should handle malformed scan reports', async () => {
      fs.existsSync.mockReturnValue(true);
      fs.readFileSync.mockReturnValue('invalid json');

      await expect(scanner.scanDependencies()).rejects.toThrow();
    });
  });

  describe('integration with existing services', () => {
    test('should integrate with notification service', () => {
      const mockNotificationService = {
        send: jest.fn()
      };

      scanner.setNotificationService(mockNotificationService);
      expect(scanner.notificationService).toBe(mockNotificationService);
    });

    test('should integrate with logging service', () => {
      const mockLogger = {
        info: jest.fn(),
        error: jest.fn(),
        warn: jest.fn()
      };

      scanner.setLogger(mockLogger);
      expect(scanner.logger).toBe(mockLogger);
    });
  });
});